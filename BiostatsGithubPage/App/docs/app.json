[{"name":"app.R","content":"library(shiny)\nlibrary(DT)\nlibrary(bslib)\nlibrary(broom)\nlibrary(utils)\nlibrary(ggplot2)\nlibrary(base64enc)\nlibrary(shinyjs)\n\nsource(\"check_ast.R\")\nsource(\"utils.R\")\nsource(\"correlation.R\")\nsource(\"visualisation.R\")\n\nui <- fluidPage(\n  useShinyjs(),\n  sidebarLayout(\n    sidebarPanel(\n      conditionalPanel(\n        condition = \"input.conditionedPanels == 'Data'\",\n        fileInput(\"file\", \"Choose CSV File\",\n                  accept = c(\"text/csv\",\n                             \"text/comma-separated-values,text/plain\",\n                             \".csv\")\n        ),\n        textInput(\"op\", \"Operations\", value = \"var / 1000\"),\n        textInput(\"new_col\", \"Name of new variable\", value = \"var\"),\n        actionButton(\"mod\", \"Modify\"),\n        verbatimTextOutput(\"mod_error\"),\n        tags$hr(),\n        helpText(\"Please upload a CSV file.\")\n      ),\n      conditionalPanel(\n        condition = \"input.conditionedPanels == 'Correlation'\",\n        corrSidebarUI(\"CORR\")\n      ),\n      conditionalPanel(\n        condition = \"input.conditionedPanels == 'Visualisation'\",\n        visSidebarUI(\"VIS\")\n      )\n    ),  \n    \n    mainPanel(\n      tabsetPanel(\n        tabPanel(\"Data\",\n            DTOutput(\"df\")\n        ),\n        \n        tabPanel(\"Correlation\",\n            corrUI(\"CORR\")\n        ),\n        \n        tabPanel(\"Visualisation\",\n            visUI(\"VIS\")\n        ),\n        \n        id = \"conditionedPanels\"   \n      )\n    )\n    \n  )\n)\n\nserver <- function(input, output) {\n  data <- reactiveValues(df = NA)\n  output$df <- renderDT({\n    req(input$file)\n    df <- try(read.csv(input$file$datapath))\n    if (inherits(df, \"try-error\")) {\n      err <- conditionMessage(attr(e, \"condition\"))\n      showNotification(err)\n      return(NULL)\n    } \n    data$df <- df\n    req(!is.na(data$df))\n    datatable(data$df, options = list(pageLength = 10)) \n  })\n\n  observeEvent(input$mod, {\n    req(!is.null(data$df))\n    req(is.data.frame(data$df))\n    req(input$op)\n    req(input$new_col)\n    dt <- data$df\n    op <- input$op\n    new_col <- input$new_col\n    new <- NULL\n    err <- NULL\n    e <- try({\n      ast <- get_ast(str2lang(op))\n      ast <- ast[[length(ast)]]\n    })\n    if (e == \"Error\") {\n      showNotification(\"Found unallowed function\")\n      return()\n    } else if (inherits(e, \"try-error\")) {\n      showNotification(e)\n      return()\n    }\n    e <- try(\n      new <- with(dt, eval(parse(text = op)))\n    )\n    if (inherits(e, \"try-error\")) {\n      err <- conditionMessage(attr(e, \"condition\"))\n    } else {\n      data$df[, new_col] <- new\n    }\n    output$df <- renderDT(data$df)\n    output$mod_error <- renderText(err)  \n    return(df)\n  })\n  \n  listResults <- reactiveValues(curr_data = NULL, curr_name = NULL,\n                                all_data = list(), all_names = list())\n  corrServer(\"CORR\", data, listResults)\n  visServer(\"VIS\", data, listResults)\n  \n}\n\nshinyApp(ui, server)","type":"text"},{"name":"check_ast.R","content":"get_ast <- function(inp) {\n  if (!is.call(inp)) {\n    return(inp)\n  }\n\n  inp <- as.list(inp)\n\n  # check if is function\n  fct <- inp[[1]]\n\n  allowed_fcts <- c(\n    \"-\", \"+\", \"*\", \"/\",\n    \"log\", \"log10\", \"sqrt\", \"exp\", \"^\",\n    \"sin\", \"cos\", \"tan\", \"tanh\", \"sinh\", \"cosh\", \"acos\", \"asin\", \"atan\",\n    \"is.numeric\", \"is.character\", \"is.logical\", \"is.factor\", \"is.integer\",\n    \"as.numeric\", \"as.character\", \"as.logical\", \"as.factor\", \"as.integer\",\n    \">\", \"<\", \"<=\", \">=\", \"==\", \"!=\",\n    \"abs\", \"ceiling\", \"floor\", \"trunc\", \"round\",\n    \"grep\", \"substr\", \"sub\", \"paste\", \"paste0\",\n    \"strsplit\", \"tolower\", \"toupper\",\n    \"dnorm\", \"pnorm\", \"qnorm\", \"rnorm\", \"dbinom\",\n    \"pbinom\", \"qbinom\", \"rbinom\", \"dpois\",\n    \"ppois\", \"rpois\", \"dunif\", \"punif\", \"qunif\", \"runif\",\n    \"mean\", \"sd\", \"median\", \"quantile\", \"range\",\n    \"sum\", \"diff\", \"min\", \"max\", \"scale\",\n    \"c\", \"vector\", \"length\", \"matrix\"\n  )\n\n  check <- deparse(fct)\n\n  if ((check %in% allowed_fcts) == FALSE) {\n    return(\"Error\")\n  }\n\n  lapply(inp, get_ast)\n}\n","type":"text"},{"name":"correlation.R","content":"corrSidebarUI <- function(id) {\n    tabPanel(\n      \"Correlation\",\n      textInput(NS(id, \"dep\"), \"dependent Variable\", value = \"var1\"),\n      textInput(NS(id, \"indep\"), \"independent Variable\", value = \"var2\"),\n      actionButton(NS(id, \"pear\"), \"Pearson correlation\"),\n      actionButton(NS(id, \"spear\"), \"Spearman correlation\"),\n      actionButton(NS(id, \"kendall\"), \"Kendall correlation\"),\n      sliderInput(NS(id, \"conflevel\"), \"Confidence level of the interval\",\n                  min = 0, max = 1, value = 0.95),\n      selectInput(NS(id, \"alt\"), \"Alternative hypothesis\",\n                  c(\"Two sided\" = \"two.sided\",\n                    \"Less\" = \"less\",\n                    \"Greater\" = \"greater\"))\n    )\n}\n\ncorrUI <- function(id) {\n  fluidRow(\n        tags$head(\n          tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js\"),\n          tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js\"),\n          tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/html2canvas/0.4.1/html2canvas.min.js\"),\n          tags$script(src = \"download.js\")\n        ),\n        h4(strong(\"Results of test:\")),\n        tableOutput(NS(id, \"corr_result\")),\n        verbatimTextOutput(NS(id, \"corr_error\")),\n        actionButton(NS(id, \"corr_save\"), \"Add output to result-file\"),\n        actionButton(NS(id, \"download_corr\"), \"Save results\"),\n        checkboxGroupInput(NS(id, \"TableSaved\"), \"Saved results to file\", NULL)\n  )\n}\n\ncorrServer <- function(id, data, listResults) {\n  moduleServer(id, function(input, output, session) {  \n      corr_fct <- function(method) {\n        req(is.data.frame(data$df))\n        df <- data$df\n        req(input$dep)\n        req(input$indep)\n        dep <- input$dep\n        indep <- input$indep\n        d <- df\n        fit <- NULL\n        err <- NULL\n        e <- try(\n          fit <- broom::tidy(\n            cor.test(d[, dep], d[, indep],\n                     method = method,\n                     alternative = input$alt,\n                     conf.level = input$conflevel))\n        )\n        if (inherits(e, \"try-error\")) {\n          err <- conditionMessage(attr(e, \"condition\"))\n        } else {\n          listResults$curr_data <- renderTable(fit, digits = 6)\n          listResults$curr_name <- paste(\"Test Nr\", length(listResults$all_names) + 1, \"Conducted test: \", method)\n          listResults$all_data[[length(listResults$all_data) + 1]] <- fit\n          listResults$all_names <- c(listResults$all_names, \n                                     paste(\"Test Nr\", length(listResults$all_names) + 1, \"Conducted test: \", method))\n          output$corr_result <- renderTable(fit, digits = 6)\n          output$corr_error <- renderText(err)  \n        }\n      }\n      \n      observeEvent(input$pear, {\n        corr_fct(\"pearson\")\n      })\n      output$cor_result <- renderTable({\n        listResults$curr_data\n        }, digits = 6\n      )\n      \n      observeEvent(input$spear, {\n        corr_fct(\"spearman\")\n      })\n      output$cor_result <- renderTable({\n        listResults$curr_data\n        }, digits = 6\n      )\n      \n      observeEvent(input$kendall, {\n        corr_fct(\"kendall\")\n      })\n      output$cor_result <- renderTable({\n        listResults$curr_data\n        }, digits = 6\n      )\n      \n      observeEvent(input$corr_save, {\n        updateCheckboxGroupInput(session, \"TableSaved\",\n                                 choices = listResults$all_names)\n      })\n      \n      observeEvent(input$download_corr, {\n        indices <- which(input$TableSaved == listResults$all_names)\n        req(length(indices) >= 1)\n        l <- listResults$all_data[indices]\n        jsString <- character(length(l))\n        for (i in seq_along(l)) {\n           if (inherits(l[[i]], \"ggplot\")) {\n             fn <- tempfile(fileext = '.png')\n             ggsave(plot = l[[i]], filename = fn)\n             jsString[i] <- paste0(\"data:image/png;base64,\", base64enc::base64encode(fn))\n             unlink(fn)\n           } else if (inherits(l[[i]], \"data.frame\")) {\n             jsString[i] <- DF2String(l[[i]])\n           } else if (is.character(l[[i]])) {\n             jsString[i] <- l[[i]]\n           }\n        }\n        session$sendCustomMessage(type = \"downloadZip\",\n                                  list(numberOfResults = length(jsString),\n                                       FileContent = jsString))\n      })\n      \n\t})\n  \n  return(listResults)\n}\n\n\n\n\n\n","type":"text"},{"name":"test.R","content":"setwd(\"/home/konrad/Documents/GitHub/shinychem/BiostatsGithubPage/App\")\nshinylive::export(\".\", \"docs\", verbose = TRUE)\nhttpuv::runStaticServer(\"docs\")\n","type":"text"},{"name":"utils.R","content":"DF2String <- function(df) {\n\tresNames <- names(df)\n\tresNames <- paste(resNames, collapse = \"\\t\")\n\tresNames <- paste(resNames, \"\\n\")\n\tres <- apply(df, 1, function(x) {\n\t\tx <- as.character(x)\n\t\tx <- paste(x, collapse = \"\\t\")\n\t\treturn(x)\n\t})\n\tres <- paste0(resNames, \"\\n\", res, collapse = \"\")\n\tres <- paste0(res, \"\\n\")\n}\n","type":"text"},{"name":"visualisation.R","content":"visSidebarUI <- function(id) {\n  tabPanel(\n    \"Visualisation\",\n    textInput(NS(id , \"yVar\"), \"Y variable\", value = \"y\"),\n    textInput(NS(id, \"xVar\"), \"X variable\", value = \"x\"),\n    radioButtons(NS(id, \"xType\"), \"Type of x\",\n                 choices = c(\n                   factor = \"factor\",\n                   numeric = \"numeric\"\n                 ),\n                 selected = \"factor\"\n    ),\n    textInput(NS(id, \"xaxisText\"), \"X axis label\", value = \"x label\"),\n    textInput(NS(id, \"yaxisText\"), \"Y axis label\", value = \"y label\"),\n    selectInput(NS(id, \"fitMethod\"), \"Choose a fitting method\",\n                c(\n                  \"none\" = \"none\",\n                  \"lm\" = \"lm\",\n                  \"glm\" = \"glm\",\n                  \"gam\" = \"gam\",\n                  \"loess\" = \"loess\"\n                ),\n                selectize = FALSE\n    ),\n    textInput(NS(id, \"fill\"), \"Fill variable\"),\n    textInput(NS(id, \"legendTitleFill\"), \"Legend title for fill\", value = \"Title fill\"),\n    textInput(NS(id, \"col\"), \"Colour variable\"),\n    textInput(NS(id, \"legendTitleCol\"), \"Legend title for colour\", value = \"Title colour\"),\n    selectInput(NS(id, \"theme\"), \"Choose a 'colour' theme\",\n                c(\n                  \"BuPu\" = \"BuPu\",\n                  \"RdYIBu\" = \"RdYIBu\",\n                  \"Paired\" = \"Paired\",\n                  \"PuOr\" = \"PuOr\",\n                  \"Spectral\" = \"Spectral\",\n                  \"Pastel1\" = \"Pastel1\",\n                  \"hue\" = \"hue\",\n                  \"grey\" = \"grey\"\n                ),\n                selectize = FALSE\n    ),\n    selectInput(NS(id, \"themeFill\"), \"Choose a 'fill' theme\",\n                c(\n                  \"BuPu\" = \"BuPu\",\n                  \"RdYIBu\" = \"RdYIBu\",\n                  \"Paired\" = \"Paired\",\n                  \"PuOr\" = \"PuOr\",\n                  \"Spectral\" = \"Spectral\",\n                  \"Pastel1\" = \"Pastel1\",\n                  \"hue\" = \"hue\",\n                  \"grey\" = \"grey\"\n                ),\n                selectize = FALSE\n    ),\n    radioButtons(NS(id, \"facetMode\"),\n                 \"Choose Facet Mode:\",\n                 choices = c(\"none\", \"facet_wrap\", \"facet_grid\")\n    ),\n    textInput(NS(id, \"facetBy\"), \"split plot by\")\n    )\n}\n\nvisUI <- function(id) {\n  fluidRow(\n    tags$head(\n      tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js\"),\n      tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js\"),\n      tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/html2canvas/0.4.1/html2canvas.min.js\"),\n      tags$script(src = \"download.js\")\n    ),\n    br(),\n    tabsetPanel(\n      tabPanel(\"Boxplot\",\n          br(),\n          actionButton(NS(id, \"CreatePlotBox\"), \"Create plot\")\n      ),\n      tabPanel(\"Scatterplot\",\n          br(),\n          actionButton(NS(id, \"CreatePlotScatter\"), \"Create plot\") \n      ),\n      tabPanel(\"Lineplot\",\n          br(),\n          actionButton(NS(id, \"CreatePlotLine\"), \"Create plot\")\n      ),\n      id = \"VisConditionedPanels\"   \n    ),\n    plotOutput(NS(id, \"plotResult\")),\n    actionButton(NS(id, \"plotSave\"), \"Add output to result-file\"),\n    checkboxGroupInput(NS(id, \"TableSaved\"), \"Saved results to file\", NULL),\n    fluidRow(\n      column(4,\n        numericInput(NS(id, \"widthPlot\"), \"Width of plot [cm]\", value = 10)\n      ),\n      column(4,\n        numericInput(NS(id, \"heightPlot\"), \"Height of plot [cm]\", value = 10)\n      ),\n      column(4,\n        numericInput(NS(id, \"resPlot\"), \"Resolution of plot\", value = 300)\n      ),\n    ),\n    fluidRow(\n      column(12,\n        actionButton(NS(id, \"downloadViss\"), \"Save results\")\n      )\n    )\n  )\n}\n\nvisServer <- function(id, data, listResults) {\n  moduleServer(id, function(input, output, session) {  \n    \n    plotFct <- function(method) {\n      req(is.data.frame(data$df))\n      df <- data$df\n      req(input$yVar)\n      req(input$xVar)\n      x <- input$xVar; y <- input$yVar\n      colNames <- names(df)\n      checkX <- x %in% colNames\n      checkY <- y %in% colNames\n      if (!checkX) showNotification(\"X variable not found\", duration = 0)\n      if (!checkY) showNotification(\"Y variable not found\", duration = 0) \n      req(checkX)\n      req(checkY)\n      width <- input$widthPlot\n      height <- input$heightPlot\n      resolution <- input$resPlot\n      if (width <= 0) {\n        showNotification(paste(\"width has to be a positive number is changed to 10 cm\"), duration = 0)\n        width <- 10\n      }\n      if (height <= 0) {\n        showNotification(paste(\"height has to be a positive number is changed to 10 cm\"), duration = 0)\n        height <- 10\n      }\n      if (width > 100) {\n        showNotification(paste(\"width exceeds max value of 100 cm. Is set to 100 cm.\"), duration = 0)\n        width <- 100\n      }\n      if (height > 100) {\n        showNotification(paste(\"height exceeds max value of 100 cm. Is set to 100 cm.\"), duration = 0)\n        height <- 100\n      }\n      col <- input$col\n      fill <- input$fill\n      if ( !(fill %in% names(df)) && (fill != \"\") ) showNotification(\"fill variable not found\", duration = 0)\n      if ( !(col %in% names(df)) && (fill != \"\") ) showNotification(\"colour variable not found\", duration = 0)\n      req( (fill %in% names(df)) || (fill == \"\") )\n      req( (col %in% names(df)) || (col == \"\") )\n      fillTitle <- input$legendTitleFill\n      colTitle <- input$legendTitleCol\n      xlabel <- input$xaxisText\n      ylabel <- input$yaxisText\n      xtype <- input$xType\n      theme <- input$theme\n      themeFill <- input$themeFill\n      facetMode <- input$facetMode\n      facet <- input$facetBy\n      fitMethod <- input$fitMethod\n      \n      xd <- NULL\n      if (xtype == \"numeric\") {\n        xd <- as.numeric(df[,x])\n      } else {\n        xd <- as.factor(df[,x])\n      }\n      yd <- as.numeric(df[,y])\n      if (fitMethod != \"none\" && !is.null(fitMethod) && xtype != \"numeric\") {\n        showNotification(\"Fit method will be ignored as X variable is not numerical\", duration = 0)\n      }\n      \n      pfct <- function() {\n        if ( (fill == \"\") && (col == \"\")) {\n          p <- ggplot(data = df, aes(x = xd, y = yd)) +\n            ylab(ylabel) +\n            xlab(xlabel)  \n        } else if ((fill != \"\") && (col != \"\") ) {\n          p <- ggplot(data = df,\n                      aes(x = xd, y = yd,\n                          fill = df[,fill], color = df[,col]) ) +\n            ylab(ylabel) +\n            xlab(xlabel) +\n            guides(fill = guide_legend(title = fill_title), col = guide_legend(title = col_title))       \n        } else if ( (fill != \"\") && (col == \"\") ) {\n          p <- ggplot(data = df,\n                      aes(x = xd, y = yd,\n                          fill = df[,fill]) ) +\n            ylab(ylabel) +\n            xlab(xlabel) +\n            guides(fill = guide_legend(title = fill_title) )\n        } else if ( (fill == \"\") && (col != \"\") ) {\n          p <- ggplot(data = df,\n                      aes(x = xd, y = yd,\n                          color = df[,col]) ) +\n            ylab(ylabel) +\n            xlab(xlabel) +\n            guides(col = guide_legend(title = col_title) )\n        }\n        if (method == \"box\") {\n          p <- p +\n            scale_color_brewer(palette = theme) +\n            scale_fill_brewer(palette = themeFill)\n          p <- p + geom_boxplot()\n        } else if (method == \"dot\") {\n          p <- p +\n            scale_color_brewer(palette = theme) \n          p <- p + geom_point() +   geom_smooth(method = fitMethod) \n          if (fitMethod != \"\" && !is.null(fitMethod) && fitMethod != \"none\") p <- p + stat_poly_eq(ggpmisc::use_label(c(\"eq\", \"n\", \"R2\", \"p\", \"F\"))) \n        } else if (method == \"line\") {\n          p <- p +\n            scale_color_brewer(palette = theme) \n          p <- p + geom_line()\n        }  \n        if (facetMode == \"facet_wrap\") {\n          p <- p + facet_wrap(~ df[,facet], scales = \"free\")\n        } else if (facetMode == \"facet_grid\") {\n          p <- p + facet_grid(. ~  df[,facet], scales = \"free\")\n        }\n        return(p)\n      }\n      \n      p <- tryCatch({\n        p <- pfct()\n      }, \n      warning = function(warn) {\n        showNotification(paste(\"A warning occurred: \", conditionMessage(warn)), duration = 0)\n      }, \n      error = function(err) {\n        showNotification(paste(\"An error occurred: \", conditionMessage(err)), duration = 0)\n      })\n      output$plotResult <- renderPlot(p)\n      listResults$curr_data <- p\n      listResults$curr_name <- paste(\"Plot Nr\",\n                                     length(listResults$all_names) + 1,  paste(\"Type: \", method))\n      listResults$all_data[[length(listResults$all_data) + 1]] <- p\n      listResults$all_names[[length(listResults$all_names) + 1]] <- listResults$curr_name\n    }\n    \n    observeEvent(input$CreatePlotBox, {\n      req(is.data.frame(data$df))\n      plotFct(\"box\")\n    })\n    output$plotResult <- renderPlot({\n      renderPlot(listResults$curr_data)\n    })\n    \n    observeEvent(input$CreatePlotScatter, {\n      req(is.data.frame(data$df))\n      plotFct(\"dot\")\n    })\n    output$plotResult <- renderPlot({\n      renderPlot(listResults$curr_data)\n    })\n    \n    observeEvent(input$CreatePlotLine, {\n      req(is.data.frame(data$df))\n      plotFct(\"line\")\n    })\n    output$plotResult <- renderPlot({\n      renderPlot(listResults$curr_data)\n    })\n    \n    observeEvent(input$plotSave, {\n      updateCheckboxGroupInput(session, \"TableSaved\",\n                               choices = listResults$all_names)\n    })\n    \n    observeEvent(input$downloadViss, {\n      indices <- which(input$TableSaved == listResults$all_names)\n      req(length(indices) >= 1)\n      l <- listResults$all_data[indices]\n      jsString <- character(length(l))\n      for (i in seq_along(l)) {\n        if (inherits(l[[i]], \"ggplot\")) {\n          fn <- tempfile(fileext = '.png')\n          ggsave(plot = l[[i]], filename = fn)\n          jsString[i] <- paste0(\"data:image/png;base64,\", base64enc::base64encode(fn))\n          unlink(fn)\n        } else if (inherits(l[[i]], \"data.frame\")) {\n          jsString[i] <- DF2String(l[[i]])\n        } else if (is.character(l[[i]])) {\n          jsString[i] <- l[[i]]\n        }\n      }\n      session$sendCustomMessage(type = \"downloadZip\",\n                                list(numberOfResults = length(jsString),\n                                     FileContent = jsString))\n    })\n    \n  })\n}\n","type":"text"},{"name":"www/download.js","content":"Shiny.addCustomMessageHandler('downloadZip', function(message) {\n  var FileContent = message.FileContent;\n  if( (typeof FileContent) == \"string\") {\n    if (FileContent.startsWith(\"data:image\")) {\n      var fileName = 'file' + (i + 1) + '.png'; \n      var zip = new JSZip();\n      var imageData = atob(FileContent.split(',')[1]);\n      var byteArray = new Uint8Array(imageData.length);\n      for (var i = 0; i < imageData.length; i++) {\n        byteArray[i] = imageData.charCodeAt(i);\n      }\n      zip.file(fileName, byteArray, {binary: true});\n      zip.generateAsync({type: 'blob'}).then(function(content) {\n        saveAs(content, 'download.zip');\n      });\n    } else {\n      var zipText = new JSZip();\n      var fileNameText = 'file' + 1 + '.txt'; \n      zipText.file(fileNameText, FileContent);\n      zipText.generateAsync({type: 'blob'}).then(function(content) {\n        saveAs(content, 'download.zip');\n      });\n    }\n  } else {\n    var zip = new JSZip();\n    for (var i in FileContent) {\n      if (FileContent[i].startsWith(\"data:image\")) {\n        var fileName = 'file' + (i + 1) + '.png'; \n        var imageData = atob(FileContent[i].split(',')[1]);\n        var byteArray = new Uint8Array(imageData.length);\n        for (var i = 0; i < imageData.length; i++) {\n          byteArray[i] = imageData.charCodeAt(i);\n        }\n        zip.file(fileName, byteArray, {binary: true});\n      } else {\n        var fileName = 'file' + (i + 1) + '.txt'; \n        zip.file(fileName, FileContent[i]); \n      }\n    }\n    zip.generateAsync({type: 'blob'}).then(function(content) {\n      saveAs(content, 'download.zip');\n    });\n  }\n});","type":"text"}]
